name "orientation_estimator"
#version '1.0'


using_library "aggregator"
using_library "quater_ikf"

import_types_from "base"
import_types_from "aggregator"
import_types_from "orientationTypes.hpp"

task_context 'BaseEstimator' do
    needs_configuration

    #******************************
    #******* Input Ports **********
    #******************************
    input_port("imu_orientation", "/base/samples/RigidBodyState").
      needs_reliable_connection.
      doc 'IMU(XSens) init orientation in quaternion.'

    input_port("fog_samples","/base/samples/IMUSensors").
      needs_reliable_connection.
      doc 'optic gyro angular velocity 1D (Z axis).'

    input_port("heading_correction", "/base/Angle").
      needs_reliable_connection.
      doc 'This angle will be applied to the current heading'

    #******************************
    #** Aggregator parameters ***** 
    #******************************
    stream_aligner() do
	align_port("imu_orientation", 0.01)
	align_port("fog_samples", 0.01)
	max_latency(0.3)
    end

    #******************************
    #******* Output Ports *********
    #******************************
    output_port('attitude_b_g', '/base/samples/RigidBodyState');
      doc 'timestamped state vector holding orientation and angular velocity with respect to the Earth fixed frame (geographic frame).'

    #******************************
    #**** Location Properties *****
    #******************************
    property('latitude', 'double', 0.926478944).
	doc 'Latitude of Bremen in radians (equivalent to 53.083333 degrees).'

    property('longitude', 'double', 0.153588974).
	doc 'Longitude of Bremen in radians (equivalent to 8.8 degrees).'

    property('altitude', 'double', 12).
	doc 'Altitude of Bremen in meters'

    property('magnetic_declination', 'double', 0.023561944).
	doc 'Bremen magnetic declination in radians (equivalent to 1.35 degrees EAST).'

    property('magnetic_declination_mode', 'int', 1).
	doc 'The declination is positive when the magnetic north is east of true north'
	doc '1 is EAST, which means positive declination. 2 is WEST, which means negative declination.'
	
    property('dip_angle', 'double', 1.187696556).
	doc 'Dip angle of Bremen in radians (equivalent to 68.05 degrees ).'    

    #******************************
    #**** Sensor Properties *****
    #******************************
    # For FOG

    property "gbiasof", "/base/Vector3d"
	doc "bias offset in static regimen for the Gyroscopes"
	
    #******************************
    #**** Filter Properties *******
    #******************************
    property('orientation_cov', '/base/Matrix3d').
	doc 'override orientation covariance, if it is not NaN or zero.'
    property('angular_velocity_cov', '/base/Matrix3d').
	doc 'override angular velocity covariance, if it is not NaN or zero.'
	
    property('use_initial_heading', 'bool', false).
	doc 'true if initial heading parameter should be used.'
    property('initial_heading', 'double', 0.0).
	doc 'Initial heading in radians.'
	
    property('substract_earth_rotation', 'bool', true).
	doc 'true if the earth rotation should be substracted.'
	
    #******************************
    #********* Operations *********
    #******************************

    # Resets the current heading, usually to the true north
    #
    # For the purpose of aligning the heading to an absolute heading (e.g. true
    # north), addHeadingOffset should be preferred. This is kept for
    # backward-compatibility
    operation('resetHeading').
        returns('bool').
        argument('heading', 'double', 'heading').
        doc 'resets the current heading, optimally to the true north'

    # Add an offset to the current heading
    #
    # This is commonly used to align the heading estimate to the true north. It
    # should be preferred to resetHeading as the offset is a constant, whereas
    # resetting to an absolute heading is time-sensitive.
    operation('addHeadingOffset').
        argument('offset', 'double', 'heading')

    port_driven
end

task_context 'IKF' do
    needs_configuration

    #****************************
    #**** Filter Properties *****
    #****************************
    property('filter_configuration', 'orientation_estimator/FilterConfiguration').
	doc 'General configuration values to run the task'

    #*********************************************
    #**** Inertial Measurement Unit Properties ***
    #*********************************************
    property('accelerometer_noise','orientation_estimator/InertialNoiseParameters').
        doc 'Inertial Sensors property.'

    property('gyroscope_noise','orientation_estimator/InertialNoiseParameters').
        doc 'Inertial Sensors property.'

    property('inclinometer_noise','orientation_estimator/InertialNoiseParameters').
        doc 'Inertial Sensors property.'

    #****************************
    #**** Adaptive Properties ***
    #****************************
    property('adaptive_config_acc', 'orientation_estimator/AdaptiveAttitudeConfig').
        doc 'Adaptive estimation of external acceleration.'

    property('adaptive_config_inc', 'orientation_estimator/AdaptiveAttitudeConfig').
        doc 'Adaptive estimation of external inclinometers.'

    #******************************
    #**** Location Properties *****
    #******************************
    property('location',"orientation_estimator/LocationConfiguration").
	    doc 'Localization properties related to the geographic place (i.e.: latitude, longitude, magnetic declination).'
	
    property('initial_heading', 'double').
	    doc 'Initial heading in radians. This is only used if imu_orientation is not connected and north seeking isnt activated.'

    #******************************
    #******* Input Ports **********
    #******************************
    input_port("imu_samples", "/base/samples/IMUSensors").
      needs_reliable_connection.
      doc 'IMU data values (acc, gyros and magn).'

    #******************************
    #** Aggregator parameters ***** 
    #******************************
    transformer do
        transformation("imu", "body")
    	align_port("imu_samples", 0.01)
        max_latency(0.05)
    end

    # The frame exported as target frame in the generated orientations
    property 'world_frame', '/std/string'

    #******************************
    #******* Output Ports *********
    #******************************
    output_port('orientation_samples_out', '/base/samples/RigidBodyState').
        doc 'provides timestamped IMU orientation samples containing the quaternion.'

    output_port('acceleration_samples_out', '/base/samples/RigidBodyAcceleration').
        doc 'provides corrected acceleration output in the body frame.'

    #******************************
    #********* Operations *********
    #******************************

    # Resets the current heading, usually to the true north, and reinitializes the filter state.
    #
    # For the purpose of aligning the heading to an absolute heading (e.g. true
    # north), addHeadingOffset should be preferred. This is kept for
    # backward-compatibility
    operation('resetHeading').
        returns('bool').
        argument('heading', 'double', 'heading')

    # Add an offset to the current heading and reinitialize the filter state.
    #
    # This is commonly used to align the heading estimate to the true north. It
    # should be preferred to resetHeading as the offset is a constant, whereas
    # resetting to an absolute heading is time-sensitive.
    operation('addHeadingOffset').
        returns('bool').
        argument('heading', 'double', 'heading').
        argument('variance', 'double', 'Initial variance of the new heading state in rad/s^2')

    #******************************
    #********** States ************
    #******************************
    runtime_states :INITIAL_ALIGNMENT, :MISSING_TRANSFORMATION
    exception_states :NAN_ERROR, :ALIGNMENT_ERROR, :CONFIGURATION_ERROR

    port_driven
end

# This is a helper task to transform the orientation in the world frame to the map frame
task_context "OrientationInMap" do
    needs_configuration

    input_port('orientation_in_world', '/base/samples/RigidBodyState').
        needs_reliable_connection.
        doc("body state in world coordinates")

    output_port('orientation_in_map', '/base/samples/RigidBodyState').
        doc("body state in map orientation")

    transformer do
        max_latency( 0.2 )
        transformation("map", "world")
        align_port("orientation_in_world", 0.01)
    end

    runtime_states :MISSING_TRANSFORMATION
    port_driven
end
